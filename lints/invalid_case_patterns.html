<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="utf-8">
      <link rel="shortcut icon" href="../dart-192.png">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
      <meta name="mobile-web-app-capable" content="yes">
      <meta name="apple-mobile-web-app-capable" content="yes">
      <meta http-equiv="refresh" content="0; url=https://dart.dev/lints/invalid_case_patterns">
      <link rel="canonical" href="https://dart.dev/lints/invalid_case_patterns">
      <title>invalid_case_patterns</title>
      <link rel="stylesheet" href="../styles.css">
   </head>
   <body>
      <div class="wrapper">
         <header>
            <h1>invalid_case_patterns</h1>
            <p>Group: errors</p>
            <p>Maturity: <span style="color:hotpink;font-weight:bold;" >experimental</span></p>
            <div class="tooltip">
               <p>Dart SDK: >= 3.0.0</p>
               <span class="tooltip-content">Since info is static, may be stale</span>
            </div>
            <a class="style-type" href="https://medium.com/dartlang/quick-fixes-for-analysis-issues-c10df084971a"><!--suppress HtmlUnknownTarget --><img alt="has-fix" src="has-fix.svg"></a>
            <ul>
               <li><a href="index.html">View all <strong>Lint Rules</strong></a></li>
               <li><a href="https://dart.dev/guides/language/analysis-options#enabling-linter-rules">Using the <strong>Linter</strong></a></li>
            </ul>
            <p><a class="overflow-link" href="index.html">View all <strong>Lint Rules</strong></a></p>
            <p><a class="overflow-link" href="https://dart.dev/guides/language/analysis-options#enabling-linter-rules">Using the <strong>Linter</strong></a></p>
         </header>
         <section>
            
            <p>Some case expressions that are valid in Dart 2.19 and below will become an error
or have changed semantics when a library is upgraded to 3.0. This lint flags
those expressions in order to ease migration to Dart 3.0.</p>
<p>Some valid switch cases in 2.19 will become compile errors in Dart 3.0:</p>
<ul>
<li>Set literals</li>
<li>Parenthesized expressions</li>
<li>Calls to <code>identical()</code>.</li>
<li>Unary operator expressions <code>!</code>, <code>-</code>, or <code>~</code> (except for <code>-</code> before an integer
literal, which is a valid pattern and is fine)</li>
<li>Binary operator expressions <code>!=</code>, <code>==</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~/</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>,
<code>&lt;&lt;</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>??</code>.</li>
<li>Conditional operator <code>?:</code></li>
<li><code>.length</code> calls on strings</li>
<li><code>is</code> and <code>is!</code> expressions</li>
</ul>
<p>Examples of all of them:</p>
<pre><code class="language-dart">switch (obj) {
  case {1}: // Set literal.
  case (1): // Parenthesized expression.
  case identical(1, 2): // `identical()` call.
  case -pi: // Unary operator.
  case 1 + 2: // Binary operator.
  case true ? 1 : 2: // Conditional operator.
  case 'hi'.length: // .length call.
  case i is int: // is expression.
}
</code></pre>
<p>Some valid switch cases in 2.19 are also syntactically valid patterns, but the
pattern matching behavior may be different from the current constant equality
behavior. They are:</p>
<p><strong>List and map literals.</strong> A list or map literal can appear as a constant in a
case:</p>
<pre><code class="language-dart">switch (obj) {
  case [1, 2]: ...
  case {'k': 'v'}: ...
}
</code></pre>
<p>Currently, the case will only match if the incoming value has the same identity
as the constant. So:</p>
<pre><code class="language-dart">test(List&lt;int&gt; list) {
  switch (list) {
    case [1, 2]: print('Matched'); break;
    default: print('Did not match'); break;
  }
}

main() {
  test(const [1, 2]); // Prints &quot;Matched&quot;.
  test([1, 2]); // Prints &quot;Did not match&quot;.
}
</code></pre>
<p>With patterns, a list or map literal becomes a list or map pattern. The pattern
destructures the incoming object and matches if the subpatterns all match. In
other words, list and map pattern match using something more like deep equality.</p>
<p>With Dart 3.0, the above program prints &quot;Matched&quot; twice.</p>
<p><strong>Constant constructor calls.</strong> Similar to collections, you can construct a
constant instance of a class in a case:</p>
<pre><code class="language-dart">class Point {
  final int x;
  final int y;
  const Point({this.x, this.y});
}

test(Point p) {
  switch (p) {
    case Point(x: 1, y: 2): print('Matched'); break;
    default: print('Did not match'); break;
  }
}

main() {
  test(const Point(1, 2)); // Prints &quot;Matched&quot;.
  test(Point(1, 2)); // Prints &quot;Did not match&quot;.
}
</code></pre>
<p>Again, like collections, the case currently only matches if the incoming value
has the same identity. With patterns, the <code>Point(...)</code> syntax becomes an object
pattern that destructures the incoming point, calls the <code>x</code> and <code>y</code> getters on
it and then matches the results of those against the corresponding subpatterns.</p>
<p>In this example, it will print &quot;Matched&quot; twice.</p>
<p>Note that object patterns only support named fields. So any constant constructor
in a case today that has positional arguments will become a compile-time error
when parsed as a pattern. A constant constructor call with no arguments is a
valid object pattern and only does a type test:</p>
<pre><code class="language-dart">class Thing {
  const Thing();
}

test(Thing t) {
  switch (t) {
    case Thing(): print('Matched'); break;
    default: print('Did not match'); break;
  }
}

main() {
  test(const Thing()); // Prints &quot;Matched&quot;.
  test(Thing()); // Prints &quot;Did not match&quot;.
}
</code></pre>
<p>When interpreted as a pattern, this prints &quot;Matched&quot; twice.</p>
<p><strong>Wildcards.</strong> Today, you can have a constant named <code>_</code>:</p>
<pre><code class="language-dart">test(int n) {
  const _ = 3;
  switch (n) {
    case _: print('Matched'); break;
    default: print('Did not match'); break;
  }
}

main() {
  test(3); // Prints &quot;Matched&quot;.
  test(5); // Prints &quot;Did not match&quot;.
}
</code></pre>
<p>With patterns, the identifier <code>_</code> is treated as a pattern that matches all
values, so this prints &quot;Matched&quot; twice.</p>
<p><strong>Logic operators.</strong> The logic operators <code>&amp;&amp;</code> and <code>||</code> are valid constant
expressions and also valid patterns. As a constant expression, they simply
evaluate the expression to a boolean and match if the incoming value is equal to
that boolean value. So:</p>
<pre><code class="language-dart">test(bool b) {
  switch (b) {
    case true &amp;&amp; false: print('Matched'); break;
    default: print('Did not match'); break;
  }
}

main() {
  test(false); // Prints &quot;Matched&quot;.
  test(true); // Prints &quot;Did not match&quot;.
}
</code></pre>
<p>With Dart 3.0, these become patterns. The above example prints &quot;Did not match&quot;
twice because no boolean value can be both true and false.</p>
<p>Many of invalid cases can be mechanically changed to something that is valid
both in Dart today and valid and means the same in Dart 3.0.</p>
<p><strong>Parenthesized expressions:</strong> Provided the inner expression is one that's not
broken in Dart 3.0, just discard the parentheses.</p>
<p><strong>List literals, map literals, set literals, and constant constructor calls:</strong>
Put <code>const</code> before the literal or call. This turns it into a constant pattern
which preserves the current behavior:</p>
<p><strong>BAD:</strong></p>
<pre><code class="language-dart">case [1, 2]:
case {'k': 'v'}:
case {1, 2}:
case Point(1, 2):
</code></pre>
<p><strong>GOOD:</strong></p>
<pre><code class="language-dart">case const [1, 2]:
case const {'k': 'v'}:
case const {1, 2}:
case const Point(1, 2):
</code></pre>
<ul>
<li>
<p><strong>Wildcards:</strong> Rename the constant from <code>_</code> to something else. Since the name
is private, this can be done locally in the library without affecting other
code.</p>
</li>
<li>
<p><strong>Everything else:</strong> For any other invalid expression, you have to hoist the
expression out into a new named constant. For example, if you have code like
this:</p>
</li>
</ul>
<p><strong>BAD:</strong></p>
<pre><code class="language-dart">switch (n) {
  case 1 + 2: ...
}
</code></pre>
<p>It can be fixed by changing it to:</p>
<p><strong>GOOD:</strong></p>
<pre><code class="language-dart">const three = 1 + 2;

switch (n) {
 case three: ...
}
</code></pre>

            
            <h2>Usage</h2>
<p>To enable the <code>invalid_case_patterns</code> lint,
add <code>invalid_case_patterns</code> under <strong>linter &gt; rules</strong> in your
<a href="https://dart.dev/guides/language/analysis-options"><code>analysis_options.yaml</code></a>
file:</p>
<pre><code class="language-yaml">linter:
  rules:
    - invalid_case_patterns
</code></pre>

         </section>
      </div>
      <footer>
         <p>Maintained by the <a href="https://dart.dev/">Dart Team</a></p>
         <p>Visit us on <a href="https://github.com/dart-lang/linter">GitHub</a></p>
      </footer>
   </body>
</html>
